***Note***: This module is no-longer maintained. An upstream equivalent has now been merged. Please use that instead of this module. See [https://gitlab.com/wireshark/wireshark/-/merge_requests/18890] for details.

# Introduction
This is a proof of concept lua c-module that exposes Wireshark's "conversation data" and "packet data" APIs to Lua Wireshark dissectors. These APIs allow contextual information generated by the dissector to be stored, to be retrieved at a later point. Generally, this is useful for protocols that utilise stateful data, i.e. where the combination of several packets is more useful than the individual packets themselves.

Rather than dealing with converting conversation and packet data back and forth between lua-native and c-native types, this module stores converstaion and packet data in a Lua native format within the Lua registry. A reference to the entry within the Lua Registry is what is stored by the underlying C `conversation_add_proto_data` and `p_add_proto_data` functions.

Note: This has only been tested to the extent that the module is useful enough for me and my personal projects. Although it is at a point that I would consider 'stable', use at your own risk. Treat this as an 'alpha' or 'proof of concept', and use your own judgement on stability.

Ultimately, this is at a point that I would consider it stable enough to be included upstream in Wireshark, but I do not currently have the time to do so. My code is licensed the same as the Wireshark Core, so anyone can attempt to upstream it if they felt compelled to do so.

# Platform Compatibility
## Linux
This is the only platform that I have compiled and used the wslua\_conversations module on. It should be fairly straight forward to compile for Linux, provided you have all build dependencies installed.

## Misc \*nix (MacOS X, Solaris, BSD, ...)
I see no reason why this module should not function on these platforms, provided build dependencies are installed. I can't assist with these platforms, I don't have any actively set up to develop against.

## Windows
None of the dependencies for this module should prevent compilation on Windows. However, you are on your own here. I don't have the time to invest in figuring out how to build on Windows. In theory, all dependencies below can be installed on Windows. You will need to figure out how to install Wireshark headers to get this to work. Some modification of the meson build script will probably be necessary.

# Dependencies
* Wireshark application (for running, not building)
* Wireshark development headers (usually the wireshark-devel or wireshark-dev package on Linux)
* Lua 5.2 development headers (may be part of Wireshark, otherwise part of a lua-dev package)
* Meson build system
* A supported Meson backend (probably ninja, Visual Studio might work)
* C compiler (tested with gcc. Haven't tested clang, but it should work. No idea about MSVC)

# Building
To build:
```bash
meson build
cd build
meson compile # Or `ninja` if your version of meson is old enough to not have the 'compile' command
```

# Example usage
The example below is roughly equivalent to the C examples found in the doc/README.request\_response\_tracking and doc/README.dissector documents found within the Wireshark source distribution (or gitlab).

```lua
-- Near top of dissector.lua file
package.cpath = table.concat({ '/absolute/lib/dir/path/?.so', package.cpath }, ';')

local conversation = require "wslua_conversation"


-- etc ...


-- In dissector definition
function my_proto:dissector(buffer, pinfo, tree)
    -- etc ...

    -- Fetch conversation
    local conv  = conversation.get_conv_data(my_proto, pinfo)

    if next(conv) == nil then
        -- Nothing created yet
        conv = { some : "initial", values : "etc" }
        conversation.set_conv_data(my_proto, pinfo, conv)
    end


    -- Check if visited
    if not pinfo.visited then
        -- Update some stateful values
        conv.some_stateful_info = "blah"
        conversation.set_conv_data(my_proto, pinfo, conv)

        if some_cond then
            -- Also set packet specific data (equivalent to p_add_proto_data)
            conversation.set_packet_data(my_proto, pinfo, {some : 'more', data : 'blah' })
        end
    end

    -- etc ...

    local pdata = conversation.get_packet_data(my_proto, pinfo)

    -- etc ...
end
```
